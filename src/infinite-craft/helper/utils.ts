export const closeIconSrc =
  "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIj48cGF0aCBkPSJNMzAwLjAwMDAyLDM0OS44MzIzM0w2MC4xMDc4Miw1ODkuNzIzMzJjLTYuNTQ2ODksNi41NDc2OS0xNC43NzY0Myw5Ljg5NzE4LTI0LjY4ODYsMTAuMDQ4NTEtOS45MTEzOCwuMTUyMS0xOC4yOTIyNC0zLjE5NzQtMjUuMTQyNTYtMTAuMDQ4NTFDMy40MjU1Nyw1ODIuODcyOTgsLjAwMDAyLDU3NC41Njc4LDAsNTY0LjgwNzc0Yy4wMDAwMi05Ljc2MDA3LDMuNDI1NTctMTguMDY1MjYsMTAuMjc2NjYtMjQuOTE1NTZsMjM5Ljg5MTAxLTIzOS44OTIyTDEwLjI3NjY4LDYwLjEwNzc4QzMuNzI4OTksNTMuNTYwOTIsLjM3OTUsNDUuMzMxMzYsLjIyODE3LDM1LjQxOTIyLC4wNzYwNywyNS41MDc4OCwzLjQyNTU3LDE3LjEyNywxMC4yNzY2OCwxMC4yNzY2NiwxNy4xMjcwMiwzLjQyNTUzLDI1LjQzMjIsMCwzNS4xOTIyNiwwczE4LjA2NTI2LDMuNDI1NTMsMjQuOTE1NTYsMTAuMjc2NjZsMjM5Ljg5MjIsMjM5Ljg5MDk3TDUzOS44OTIyMiwxMC4yNzY1OWM2LjU0Njg2LTYuNTQ3NzIsMTQuNzc2NDMtOS44OTcyLDI0LjY4ODU2LTEwLjA0ODUxLDkuOTExMzQtLjE1MjE3LDE4LjI5MjIyLDMuMTk3MzgsMjUuMTQyNTYsMTAuMDQ4NTEsNi44NTExMyw2Ljg1MDI3LDEwLjI3NjY2LDE1LjE1NTUyLDEwLjI3NjY2LDI0LjkxNTU2cy0zLjQyNTUzLDE4LjA2NTIyLTEwLjI3NjY2LDI0LjkxNTU2bC0yMzkuODkwOTcsMjM5Ljg5MjI3LDIzOS44OTEwNSwyMzkuODkyMmM2LjU0NzcyLDYuNTQ2ODksOS44OTcyLDE0Ljc3NjQzLDEwLjA0ODUxLDI0LjY4ODYsLjE1MjE3LDkuOTExMzgtMy4xOTczOCwxOC4yOTIyNC0xMC4wNDg1MSwyNS4xNDI1Ni02Ljg1MDI3LDYuODUxMS0xNS4xNTU1MiwxMC4yNzY2NC0yNC45MTU1NiwxMC4yNzY2Ni05Ljc2MDA0LS4wMDAwMi0xOC4wNjUyMi0zLjQyNTU3LTI0LjkxNTU2LTEwLjI3NjY2bC0yMzkuODkyMjctMjM5Ljg5MTAxWiIvPjwvc3ZnPg==";

export const randomIcon =
  "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJhIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2MDAgNjAwIj48cGF0aCBkPSJNNjAuNTc2NTcsNjAwYy0xNy4yNTkzOCwwLTMxLjY3MDMyLTUuNzgxMjUtNDMuMjMyODItMTcuMzQzNzVTMCw1NTYuNjgyODEsMCw1MzkuNDIzNDN2LTEwOC4xNzM0M2MwLTUuMzM2MjQsMS43OTA5NC05Ljc5NTMxLDUuMzcyODItMTMuMzc3MiwzLjU4MTI2LTMuNTgxODksOC4wNDAzLTUuMzcyOCwxMy4zNzcxOC01LjM3MjgsNS4zMzYyNSwwLDkuNzk1MywxLjc5MDkxLDEzLjM3NzE4LDUuMzcyOCwzLjU4MTg3LDMuNTgxODYsNS4zNzI4Miw4LjA0MDkzLDUuMzcyODIsMTMuMzc3MnYxMDguMTczNDVjMCw1Ljc2ODc0LDIuNDAzNzYsMTEuMDU3MTgsNy4yMTEyNSwxNS44NjUzMiw0LjgwODEyLDQuODA3NDgsMTAuMDk2NTYsNy4yMTEyNCwxNS44NjUzMiw3LjIxMTI0aDEwOC4xNzM0M2M1LjMzNjI0LDAsOS43OTUzMSwxLjc5MDk0LDEzLjM3NzIsNS4zNzI4MiwzLjU4MTg5LDMuNTgxODksNS4zNzI4LDguMDQwOTMsNS4zNzI4LDEzLjM3NzE4LDAsNS4zMzY4OC0xLjc5MDkxLDkuNzk1OTMtNS4zNzI4LDEzLjM3NzE4LTMuNTgxODksMy41ODE4Ny04LjA0MDk2LDUuMzcyODItMTMuMzc3Miw1LjM3MjgySDYwLjU3NjU3Wm00NzguODQ2ODgsMGgtMTA4LjE3MzQ1Yy01LjMzNjI3LDAtOS43OTUyOC0xLjc5MDk0LTEzLjM3NzE3LTUuMzcyODItMy41ODE4OS0zLjU4MTI2LTUuMzcyODMtOC4wNDAzLTUuMzcyODMtMTMuMzc3MTgsMC01LjMzNjI1LDEuNzkwOTQtOS43OTUzLDUuMzcyODMtMTMuMzc3MTgsMy41ODE4OS0zLjU4MTg3LDguMDQwOTYtNS4zNzI4MiwxMy4zNzcxNy01LjM3MjgyaDEwOC4xNzM0NWM1Ljc2ODc0LDAsMTEuMDU3MjItMi40MDM3NiwxNS44NjUyOS03LjIxMTI1LDQuODA3NTUtNC44MDgxMiw3LjIxMTI3LTEwLjA5NjU2LDcuMjExMjctMTUuODY1MzJ2LTEwOC4xNzM0M2MwLTUuMzM2MjQsMS43OTA5NC05Ljc5NTMxLDUuMzcyODMtMTMuMzc3MiwzLjU4MTg5LTMuNTgxODksOC4wNDA5Ni01LjM3MjgsMTMuMzc3MTctNS4zNzI4LDUuMzM2ODksMCw5Ljc5NTkxLDEuNzkwOTEsMTMuMzc3MTcsNS4zNzI4LDMuNTgxODksMy41ODE4OSw1LjM3MjgzLDguMDQwOTYsNS4zNzI4MywxMy4zNzcydjEwOC4xNzM0NWMwLDE3LjI1OTM2LTUuNzgxMjcsMzEuNjcwMzEtMTcuMzQzNzUsNDMuMjMyOC0xMS41NjI0OCwxMS41NjI1LTI1Ljk3MzQ1LDE3LjM0Mzc1LTQzLjIzMjgsMTcuMzQzNzVaTTAsNjAuNTc2NTVDMCw0My4zMTcyLDUuNzgxMjUsMjguOTA2MjMsMTcuMzQzNzUsMTcuMzQzNzUsMjguOTA2MjUsNS43ODEyNyw0My4zMTcxOSwwLDYwLjU3NjU3LDBoMTA4LjE3MzQzYzUuMzM2MjQsMCw5Ljc5NTMxLDEuNzkwOTQsMTMuMzc3Miw1LjM3MjgzLDMuNTgxODksMy41ODEyNiw1LjM3MjgsOC4wNDAyOCw1LjM3MjgsMTMuMzc3MTcsMCw1LjMzNjMyLTEuNzkwOTEsOS43OTUyOC01LjM3MjgsMTMuMzc3MTctMy41ODE4NiwzLjU4MTgzLTguMDQwOTMsNS4zNzI4My0xMy4zNzcyLDUuMzcyODNINjAuNTc2NTdjLTUuNzY4NzUsMC0xMS4wNTcxOCwyLjQwMzcyLTE1Ljg2NTMyLDcuMjExMjctNC44MDc0OSw0LjgwODA2LTcuMjExMjUsMTAuMDk2NTUtNy4yMTEyNSwxNS44NjUyOXYxMDguMTczNDVjMCw1LjMzNjI3LTEuNzkwOTQsOS43OTUyOC01LjM3MjgyLDEzLjM3NzE3LTMuNTgxODksMy41ODE4My04LjA0MDkzLDUuMzcyNzctMTMuMzc3MTgsNS4zNzI4My01LjMzNjg4LDAtOS43OTU5My0xLjc5MDk0LTEzLjM3NzE4LTUuMzcyODMtMy41ODE4Ny0zLjU4MTg5LTUuMzcyODItOC4wNDA5LTUuMzcyODItMTMuMzc3MTdWNjAuNTc2NTVabTYwMCwwdjEwOC4xNzM0NWMwLDUuMzM2MjctMS43OTA5NCw5Ljc5NTI4LTUuMzcyODMsMTMuMzc3MTctMy41ODEyNiwzLjU4MTg5LTguMDQwMjgsNS4zNzI4My0xMy4zNzcxNyw1LjM3MjgzLTUuMzM2MzIsMC05Ljc5NTI4LTEuNzkwOTQtMTMuMzc3MTctNS4zNzI4My0zLjU4MTgzLTMuNTgxODktNS4zNzI4My04LjA0MDk2LTUuMzcyODMtMTMuMzc3MTdWNjAuNTc2NTVjMC01Ljc2ODc0LTIuNDAzNzItMTEuMDU3MjItNy4yMTEyNy0xNS44NjUyOS00LjgwODA2LTQuODA3NTUtMTAuMDk2NTUtNy4yMTEyNy0xNS44NjUyOS03LjIxMTI3aC0xMDguMTczNDVjLTUuMzM2MjcsMC05Ljc5NTI4LTEuNzkwOTQtMTMuMzc3MTctNS4zNzI4My0zLjU4MTgzLTMuNTgxODktNS4zNzI3Ny04LjA0MDk2LTUuMzcyODMtMTMuMzc3MTcsMC01LjMzNjg5LDEuNzkwOTQtOS43OTU5MSw1LjM3MjgzLTEzLjM3NzE3LDMuNTgxODktMy41ODE4OSw4LjA0MDktNS4zNzI4MywxMy4zNzcxNy01LjM3MjgzaDEwOC4xNzM0NWMxNy4yNTkzNSwwLDMxLjY3MDMyLDUuNzgxMjcsNDMuMjMyOCwxNy4zNDM3NXMxNy4zNDM3NSwyNS45NzM0NSwxNy4zNDM3NSw0My4yMzI4Wk0zMDEuNDQxODcsNDk1LjQzMzEzYzguMzE3NTEsMCwxNS4zMjUwMS0yLjg0ODc1LDIxLjAyMjUxLTguNTQ2MjUsNS42OTY5LTUuNjk2ODcsOC41NDUzMy0xMi43MDQwNiw4LjU0NTMzLTIxLjAyMTU3cy0yLjg0ODQzLTE1LjMyNDctOC41NDUzLTIxLjAyMTU3Yy01LjY5NzUzLTUuNjk2ODctMTIuNzA1LTguNTQ1My0yMS4wMjI1MS04LjU0NTMtOC4zMTY5MSwwLTE1LjMyNDA3LDIuODQ4NDMtMjEuMDIxNTcsOC41NDUzLTUuNjk2OSw1LjY5Njg3LTguNTQ1MzMsMTIuNzA0MDYtOC41NDUzMywyMS4wMjE1N3MyLjg0ODQzLDE1LjMyNDcsOC41NDUzLDIxLjAyMTU3YzUuNjk3NDcsNS42OTc1LDEyLjcwNDY5LDguNTQ2MjUsMjEuMDIxNTcsOC41NDYyNVptMC0zNTUuOTYyMTVjMTkuMTM0OTgsMCwzNS42Mzc1LDYuMDgxODUsNDkuNTA3NTEsMTguMjQ1NiwxMy44NzAwMSwxMi4xNjMxMiwyMC44MDUwMiwyNy40OTk2OSwyMC44MDUwMiw0Ni4wMDk3MSwwLDEzLjQxMzE2LTMuOTMwMywyNS42MjQ2OS0xMS43OTA5NiwzNi42MzQ3MS03Ljg2MDAzLDExLjAwOTM5LTE2Ljg2MjE4LDIwLjk2MTIzLTI3LjAwNjU3LDI5Ljg1NTYzLTE2LjI1MDAxLDE0Ljg1NTYtMjguMzUzNDUsMjguNjg5NjgtMzYuMzEwMyw0MS41MDIyLTcuOTU2ODgsMTIuODEyNDktMTIuNTYwMjksMjYuODM5MDYtMTMuODEwMyw0Mi4wNzk3LS42MjQ5OSw0LjkwMzc0LC44MTc0OCw5LjA3NDM5LDQuMzI3NSwxMi41MTE4OCwzLjUwOTM5LDMuNDM3NTIsNy43ODgxMSw1LjE1NjI1LDEyLjgzNjI0LDUuMTU2MjUsNC45MDM3NiwwLDkuMTQ2NTgtMS42ODI4LDEyLjcyODQzLTUuMDQ4NDUsMy41ODE4OS0zLjM2NTAyLDUuNzU3NTItNy41NzE1NSw2LjUyNjg4LTEyLjYxOTY5LDEuNzMwNjMtMTAuNjI1MDEsNS40ODA2My0yMC4xMjAzMiwxMS4yNS0yOC40ODU5NSw1Ljc2ODc0LTguMzY1NjMsMTQuODMxMi0xOC43MjYyNSwyNy4xODc1LTMxLjA4MTg3LDE4Ljk4OTk4LTE4Ljk5MDYxLDMyLjA3ODctMzQuOTY0MDgsMzkuMjY2MjItNDcuOTIwMzMsNy4xODc1Mi0xMi45NTY4OSwxMC43ODEyNS0yNy4zNjgxNCwxMC43ODEyNS00My4yMzM3OCwwLTI4Ljk0MTg4LTkuNzgzNzMtNTIuNTk1NjctMjkuMzUxMjMtNzAuOTYxMjctMTkuNTY2ODgtMTguMzY1NjUtNDQuNzM1MDEtMjcuNTQ4NDUtNzUuNTA0MzctMjcuNTQ4NDUtMjEuMjk4MTEsMC00MC43ODEyNSw0LjgxOTY4LTU4LjQ0OTM4LDE0LjQ1OTA0LTE3LjY2ODc2LDkuNjM5MzYtMzEuODE1NjEsMjMuNjQxODMtNDIuNDQwNjEsNDIuMDA3NDgtMi4zMDc1LDQuMTM1MDQtMi41ODM3Niw4LjU0NjI4LS44Mjg3NSwxMy4yMzM3OHM1LjAxMjIsNy44NzI1MSw5Ljc3MTU3LDkuNTU1MDJjNC4yNzg3NSwxLjY4MjUxLDguODM0MDcsMS44MDI4NSwxMy42NjU5MywuMzYwOTUsNC44MzE4Ny0xLjQ0MjQ3LDguNzg2MjMtNC4xNTkwNywxMS44NjMxMi04LjE0OTY4LDguMzE3NTEtMTAuNjczMTYsMTcuODQ4NzUtMTkuNDM1MDQsMjguNTkzNzUtMjYuMjg1NjUsMTAuNzQ0OTctNi44NTEyMywyMi44NzIxNi0xMC4yNzY4NSwzNi4zODE1Ny0xMC4yNzY4NVoiLz48L3N2Zz4=";

export const css = `
/* put search bar on top */
#sidebar,
.sidebar-controls {
	display: flex;
	flex-direction: column;
}

.sidebar-inner {
	order: 1;
}

.sidebar-controls {
	order: 0;
	z-index: 1;
	top: 0;
	bottom: unset !important;
	margin-top: 0px !important;
}

.sidebar-controls::before {
	display: none;
}

.sidebar-controls::after {
	content: "";
	position: absolute;
	left: 0;
	right: 0;
	bottom: -30px;
	height: 80px;
	background: linear-gradient(0deg, hsla(0, 0%, 100%, 0), #fff 60%);
	z-index: -1;
	pointer-events: none;
}

.dark-mode .sidebar-controls::after {
	background: linear-gradient(0deg, hsla(0, 0%, 100%, 0), rgba(24, 24, 27, .9) 60%);
}

.sidebar-sorting {
	order: 1;
	margin: unset !important;
}

.sorting-item {
	transform: translateY(0) !important;
	border-radius: 0 !important;
	border-bottom-right-radius: 10px !important;
	border-bottom-left-radius: 10px !important;
	border-bottom: 1px solid var(--border-color) !important;
	border-top: none !important;
	height: 31px !important; /* for whatever reasons 32px leaves a 1px gap at the bottom, ruined my day */
}

.sorting-item:hover {
	transform: translateY(0) !important;
}

.sort-name {
	border-top-left-radius: 0 !important;
	border-bottom-left-radius: 10px;
}

.sort-direction {
	border-top-right-radius: 0 !important;
	border-bottom-right-radius: 10px;
}

.sort-dropdown {
	top: 100% !important;
	transform: translate(-50%, 6px) !important;
	background: var(--background-color) !important;
	min-width: max-content !important;
	box-shadow: 0 -10px 20px 15px rgba(255, 255, 255, .06) !important;
}

.dark-mode .sort-dropdown {
	box-shadow: 0 -10px 20px 15px rgba(24, 24, 27, .06) !important;
}

.sort-dropdown-option {
	background: unset !important;
	padding: 9px 13px !important;
}

.sort-dropdown-option:hover {
	background: rgba(0, 0, 0, 0.06) !important;
}

.dark-mode .sort-dropdown-option:hover {
	background: rgba(255, 255, 255, 0.05) !important;
}

.sidebar-search {
	order: 0;
}

.sidebar-input {
	border: none !important;
	border-bottom: 1px solid var(--border-color) !important;
}

.resize-handle {
	margin-top: unset !important;
	position: absolute !important;
}

/* less dark dark theme */
.container.dark-mode {
	--border-color: #525252 !important;
	--item-bg: #18181b !important;
	--instance-bg: linear-gradient(180deg, #22252b, #18181b 80%) !important;
	--instance-bg-hover: linear-gradient(180deg, #3d4249, #18181b 80%) !important;
	--instance-border: #525252 !important;
	--instance-border-hover: #a3a3a3 !important;
	--sidebar-bg: #18181b !important;
	--background-color: #18181b !important;
	--discoveries-bg-active: #423a24 !important;
	--text-color: #fff !important;
}

.dark-mode {
	scrollbar-color: #525252 #262626 !important;
}

/* sync stuff to css var */
.save,
.modal {
	border: 1px solid var(--border-color) !important;
}

.dark-mode .menu {
	background: var(--sidebar-bg) !important;
}

.dark-mode .save:hover {
	background: var(--instance-bg) !important;
}

.dark-mode .save-selected,
.dark-mode .save-selected:hover {
	background: var(--instance-bg-hover) !important;
	border: 1px solid var(--instance-border-hover) !important;
}

.dark-mode .save-selected,
.dark-mode .save-selected .save-name-input {
	color: var(--text-color) !important;
}

.dark-mode .save .save-action-icon,
.dark-mode .save .save-icon {
	filter: invert(1) !important;
}

/* recipe modal stuff */
.recipe-modal {
	display: none;
	place-self: center;
	border-radius: 5px;
	border: 1px solid var(--border-color);
	padding: 0;
	background-color: var(--background-color);
	transition: 0.2s ease-in-out opacity;
}

.recipe-modal[open] {
	display: grid;
}

.recipe-modal.hidden {
	opacity: 0;
}

.recipe-modal-header {
	display: grid;
	grid-template-columns: 1fr auto;
	gap: 12px;
	position: sticky;
	top: 0;
	z-index: 1;
	background-color: var(--background-color);
	padding: 20px 24px;
	padding-bottom: 12px;
	align-items: center;
}

.recipe-modal-header h1,
.recipe-modal-header .item-emoji {
	font-size: 24px;
}

.recipe-modal-header .recipe-modal-close-button img {
	width: 16px;
	height: 16px;
}

.dark-mode .recipe-modal-header .recipe-modal-close-button img {
	filter: invert(1);
}

.recipe-modal-header .recipe-modal-close-button {
	display: grid;
	place-content: center;
	aspect-ratio: 1/1;
	background-color: var(--background-color);
	border: 1px solid var(--border-color);
	border-radius: 5px;
	padding: 8px;
	cursor: pointer;
}

.recipe-modal-header .recipe-modal-close-button:hover {
	background-color: color-mix(in oklab, var(--background-color), var(--text-color) 5%);
}

.recipe-modal-body {
	display: grid;
	gap: 8px;
	overflow: auto;
	padding: 20px 24px;
	padding-top: 12px;
}

.recipe-modal-body .recipe {
	display: flex;
	gap: 6px;
	align-items: center;
}

.item {
	cursor: pointer;
	padding: 8px 8px 7px;
	border-radius: 5px;
	font-size: 15.4px;
	-webkit-user-select: none;
	-moz-user-select: none;
	user-select: none;
	border: 1px solid var(--border-color);
	transition: background .15s linear;
	background: var(--item-bg);
	line-height: 1em;
	contain: layout style;
	text-overflow: ellipsis;
	overflow-x: hidden;
	white-space: nowrap
}

.item-emoji {
	font-size: 15.4px;
	pointer-events: none
}

.item:hover {
	background: var(--instance-bg-hover);
	border: 1px solid var(--instance-border-hover)
}

/* damn i hate doing this so much */
.item-wrapper {
	contain: layout style;
	display: inline-block;
	margin: 4px;
	max-width: calc(100% - 5px);
	position: relative;
}
.sidebar-sorting {
	background: var(--sidebar-bg);
}
.items-pinned {
	line-height: .5em;
	max-width: 900px;
	background-color: var(--sidebar-bg);
	position: relative;
	border-bottom: 1px solid var(--border-color);
	flex-shrink: 0; /* exorcism. i spent an hour debugging the container shrinking thinking it was js */
	max-height: 75%; /* surely nobody needs more than this right? */
}
.items-pinned-inner {
	padding: 9px;
	overflow: hidden auto;
}
.items-pinned:not(:has(.item)) {
	display: none;
}
.items-pinned .resize-handle-vertical {
	height: 3px;
	width: 100%;
	left: 0;
	top: 100%;
	position: sticky;
	cursor: ns-resize;
	z-index: 1;
}
.items-pinned .resize-handle-vertical:hover {
	background: rgba(0, 0, 0, .06);
}
.dark-mode .items-pinned .resize-handle-vertical:hover {
	background: hsla(0, 0%, 100%, .15);
}
.items {
	min-height: unset !important;
}
@media screen and (min-width:1150px) {
	.item {
		padding: 9px 10px 8px;
	}
	.item, .item-emoji {
		font-size: 16.4px;
	}
}
@media screen and (max-width: 1150px) {
	.item {
		max-width: 267px;
	}
}
@media screen and (max-width:800px) {
	.item {
		line-height: 32px;
		min-height: 32px;
		padding: 1px 9px 0;
		width: auto;
	}
}

/* fix overflow mess */
.sidebar {
	overflow: hidden;
}
.sidebar-inner {
	height: 100%;
	display: flex;
	flex-direction: column;
}
.sidebar-inner .items {
	position: relative;
	height: 100%;
	margin: unset !important;
	overflow: auto;
	padding: 0 !important;
}
.sidebar-inner .items > div {
	position: absolute;
	width: 100%;
	height: 100%;
	top: 0px;
	left: 0px;
	padding: 9px;
}
.sidebar-inner .items > .bottom-spacer,
.sidebar-inner .items > .instruction {
	display: none;
}

.random {
	width: 22px;
	cursor: pointer;
}
.random:hover {
	transform: scale(1.05);
}`;

/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Marin Atanasov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

const characterMap = {
  À: "A",
  Á: "A",
  Â: "A",
  Ã: "A",
  Ä: "A",
  Å: "A",
  Ấ: "A",
  Ắ: "A",
  Ẳ: "A",
  Ẵ: "A",
  Ặ: "A",
  Æ: "AE",
  Ầ: "A",
  Ằ: "A",
  Ȃ: "A",
  Ả: "A",
  Ạ: "A",
  Ẩ: "A",
  Ẫ: "A",
  Ậ: "A",
  Ç: "C",
  Ḉ: "C",
  È: "E",
  É: "E",
  Ê: "E",
  Ë: "E",
  Ế: "E",
  Ḗ: "E",
  Ề: "E",
  Ḕ: "E",
  Ḝ: "E",
  Ȇ: "E",
  Ẻ: "E",
  Ẽ: "E",
  Ẹ: "E",
  Ể: "E",
  Ễ: "E",
  Ệ: "E",
  Ì: "I",
  Í: "I",
  Î: "I",
  Ï: "I",
  Ḯ: "I",
  Ȋ: "I",
  Ỉ: "I",
  Ị: "I",
  Ð: "D",
  Ñ: "N",
  Ò: "O",
  Ó: "O",
  Ô: "O",
  Õ: "O",
  Ö: "O",
  Ø: "O",
  Ố: "O",
  Ṍ: "O",
  Ṓ: "O",
  Ȏ: "O",
  Ỏ: "O",
  Ọ: "O",
  Ổ: "O",
  Ỗ: "O",
  Ộ: "O",
  Ờ: "O",
  Ở: "O",
  Ỡ: "O",
  Ớ: "O",
  Ợ: "O",
  Ù: "U",
  Ú: "U",
  Û: "U",
  Ü: "U",
  Ủ: "U",
  Ụ: "U",
  Ử: "U",
  Ữ: "U",
  Ự: "U",
  Ý: "Y",
  à: "a",
  á: "a",
  â: "a",
  ã: "a",
  ä: "a",
  å: "a",
  ấ: "a",
  ắ: "a",
  ẳ: "a",
  ẵ: "a",
  ặ: "a",
  æ: "ae",
  ầ: "a",
  ằ: "a",
  ȃ: "a",
  ả: "a",
  ạ: "a",
  ẩ: "a",
  ẫ: "a",
  ậ: "a",
  ç: "c",
  ḉ: "c",
  è: "e",
  é: "e",
  ê: "e",
  ë: "e",
  ế: "e",
  ḗ: "e",
  ề: "e",
  ḕ: "e",
  ḝ: "e",
  ȇ: "e",
  ẻ: "e",
  ẽ: "e",
  ẹ: "e",
  ể: "e",
  ễ: "e",
  ệ: "e",
  ì: "i",
  í: "i",
  î: "i",
  ï: "i",
  ḯ: "i",
  ȋ: "i",
  ỉ: "i",
  ị: "i",
  ð: "d",
  ñ: "n",
  ò: "o",
  ó: "o",
  ô: "o",
  õ: "o",
  ö: "o",
  ø: "o",
  ố: "o",
  ṍ: "o",
  ṓ: "o",
  ȏ: "o",
  ỏ: "o",
  ọ: "o",
  ổ: "o",
  ỗ: "o",
  ộ: "o",
  ờ: "o",
  ở: "o",
  ỡ: "o",
  ớ: "o",
  ợ: "o",
  ù: "u",
  ú: "u",
  û: "u",
  ü: "u",
  ủ: "u",
  ụ: "u",
  ử: "u",
  ữ: "u",
  ự: "u",
  ý: "y",
  ÿ: "y",
  Ā: "A",
  ā: "a",
  Ă: "A",
  ă: "a",
  Ą: "A",
  ą: "a",
  Ć: "C",
  ć: "c",
  Ĉ: "C",
  ĉ: "c",
  Ċ: "C",
  ċ: "c",
  Č: "C",
  č: "c",
  C̆: "C",
  c̆: "c",
  Ď: "D",
  ď: "d",
  Đ: "D",
  đ: "d",
  Ē: "E",
  ē: "e",
  Ĕ: "E",
  ĕ: "e",
  Ė: "E",
  ė: "e",
  Ę: "E",
  ę: "e",
  Ě: "E",
  ě: "e",
  Ĝ: "G",
  Ǵ: "G",
  ĝ: "g",
  ǵ: "g",
  Ğ: "G",
  ğ: "g",
  Ġ: "G",
  ġ: "g",
  Ģ: "G",
  ģ: "g",
  Ĥ: "H",
  ĥ: "h",
  Ħ: "H",
  ħ: "h",
  Ḫ: "H",
  ḫ: "h",
  Ĩ: "I",
  ĩ: "i",
  Ī: "I",
  ī: "i",
  Ĭ: "I",
  ĭ: "i",
  Į: "I",
  į: "i",
  İ: "I",
  ı: "i",
  Ĳ: "IJ",
  ĳ: "ij",
  Ĵ: "J",
  ĵ: "j",
  Ķ: "K",
  ķ: "k",
  Ḱ: "K",
  ḱ: "k",
  K̆: "K",
  k̆: "k",
  Ĺ: "L",
  ĺ: "l",
  Ļ: "L",
  ļ: "l",
  Ľ: "L",
  ľ: "l",
  Ŀ: "L",
  ŀ: "l",
  Ł: "l",
  ł: "l",
  Ḿ: "M",
  ḿ: "m",
  M̆: "M",
  m̆: "m",
  Ń: "N",
  ń: "n",
  Ņ: "N",
  ņ: "n",
  Ň: "N",
  ň: "n",
  ŉ: "n",
  N̆: "N",
  n̆: "n",
  Ō: "O",
  ō: "o",
  Ŏ: "O",
  ŏ: "o",
  Ő: "O",
  ő: "o",
  Œ: "OE",
  œ: "oe",
  P̆: "P",
  p̆: "p",
  Ŕ: "R",
  ŕ: "r",
  Ŗ: "R",
  ŗ: "r",
  Ř: "R",
  ř: "r",
  R̆: "R",
  r̆: "r",
  Ȓ: "R",
  ȓ: "r",
  Ś: "S",
  ś: "s",
  Ŝ: "S",
  ŝ: "s",
  Ş: "S",
  Ș: "S",
  ș: "s",
  ş: "s",
  Š: "S",
  š: "s",
  Ţ: "T",
  ţ: "t",
  ț: "t",
  Ț: "T",
  Ť: "T",
  ť: "t",
  Ŧ: "T",
  ŧ: "t",
  T̆: "T",
  t̆: "t",
  Ũ: "U",
  ũ: "u",
  Ū: "U",
  ū: "u",
  Ŭ: "U",
  ŭ: "u",
  Ů: "U",
  ů: "u",
  Ű: "U",
  ű: "u",
  Ų: "U",
  ų: "u",
  Ȗ: "U",
  ȗ: "u",
  V̆: "V",
  v̆: "v",
  Ŵ: "W",
  ŵ: "w",
  Ẃ: "W",
  ẃ: "w",
  X̆: "X",
  x̆: "x",
  Ŷ: "Y",
  ŷ: "y",
  Ÿ: "Y",
  Y̆: "Y",
  y̆: "y",
  Ź: "Z",
  ź: "z",
  Ż: "Z",
  ż: "z",
  Ž: "Z",
  ž: "z",
  ſ: "s",
  ƒ: "f",
  Ơ: "O",
  ơ: "o",
  Ư: "U",
  ư: "u",
  Ǎ: "A",
  ǎ: "a",
  Ǐ: "I",
  ǐ: "i",
  Ǒ: "O",
  ǒ: "o",
  Ǔ: "U",
  ǔ: "u",
  Ǖ: "U",
  ǖ: "u",
  Ǘ: "U",
  ǘ: "u",
  Ǚ: "U",
  ǚ: "u",
  Ǜ: "U",
  ǜ: "u",
  Ứ: "U",
  ứ: "u",
  Ṹ: "U",
  ṹ: "u",
  Ǻ: "A",
  ǻ: "a",
  Ǽ: "AE",
  ǽ: "ae",
  Ǿ: "O",
  ǿ: "o",
  Þ: "TH",
  þ: "th",
  Ṕ: "P",
  ṕ: "p",
  Ṥ: "S",
  ṥ: "s",
  X́: "X",
  x́: "x",
  Ѓ: "Г",
  ѓ: "г",
  Ќ: "К",
  ќ: "к",
  A̋: "A",
  a̋: "a",
  E̋: "E",
  e̋: "e",
  I̋: "I",
  i̋: "i",
  Ǹ: "N",
  ǹ: "n",
  Ồ: "O",
  ồ: "o",
  Ṑ: "O",
  ṑ: "o",
  Ừ: "U",
  ừ: "u",
  Ẁ: "W",
  ẁ: "w",
  Ỳ: "Y",
  ỳ: "y",
  Ȁ: "A",
  ȁ: "a",
  Ȅ: "E",
  ȅ: "e",
  Ȉ: "I",
  ȉ: "i",
  Ȍ: "O",
  ȍ: "o",
  Ȑ: "R",
  ȑ: "r",
  Ȕ: "U",
  ȕ: "u",
  B̌: "B",
  b̌: "b",
  Č̣: "C",
  č̣: "c",
  Ê̌: "E",
  ê̌: "e",
  F̌: "F",
  f̌: "f",
  Ǧ: "G",
  ǧ: "g",
  Ȟ: "H",
  ȟ: "h",
  J̌: "J",
  ǰ: "j",
  Ǩ: "K",
  ǩ: "k",
  M̌: "M",
  m̌: "m",
  P̌: "P",
  p̌: "p",
  Q̌: "Q",
  q̌: "q",
  Ř̩: "R",
  ř̩: "r",
  Ṧ: "S",
  ṧ: "s",
  V̌: "V",
  v̌: "v",
  W̌: "W",
  w̌: "w",
  X̌: "X",
  x̌: "x",
  Y̌: "Y",
  y̌: "y",
  A̧: "A",
  a̧: "a",
  B̧: "B",
  b̧: "b",
  Ḑ: "D",
  ḑ: "d",
  Ȩ: "E",
  ȩ: "e",
  Ɛ̧: "E",
  ɛ̧: "e",
  Ḩ: "H",
  ḩ: "h",
  I̧: "I",
  i̧: "i",
  Ɨ̧: "I",
  ɨ̧: "i",
  M̧: "M",
  m̧: "m",
  O̧: "O",
  o̧: "o",
  Q̧: "Q",
  q̧: "q",
  U̧: "U",
  u̧: "u",
  X̧: "X",
  x̧: "x",
  Z̧: "Z",
  z̧: "z",
  й: "и",
  Й: "И",
  ё: "е",
  Ё: "Е",
};

const removeAccentsRegex = new RegExp(Object.keys(characterMap).join("|"), "g");

function removeAccents(string: string) {
  type char = keyof typeof characterMap;
  return string.replace(removeAccentsRegex, (char) => {
    return characterMap[char as char];
  });
}

interface Options<TItem> {
  keys: string[];
  threshold?: number;
  baseSort?: (a: RankingWithIndex<TItem>, b: RankingWithIndex<TItem>) => number;
  sorter?: (
    matchedItems: RankingWithIndex<TItem>[]
  ) => RankingWithIndex<TItem>[];
  keepDiacritics?: boolean;
}

interface Ranking {
  rankedValue: string;
  rank: number;
  keyIndex: number;
  keyThreshold?: number;
}

interface RankingWithIndex<TItem> {
  rankedValue: string;
  rank: number;
  keyIndex: number;
  keyThreshold?: number;
  item: TItem;
  index: number;
}

const rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0,
} as const;

function defaultBaseSortFn<TItem>(
  a: RankingWithIndex<TItem>,
  b: RankingWithIndex<TItem>
): number {
  return String(a.rankedValue).localeCompare(String(b.rankedValue));
}

export function matchSorter<TItem>(
  items: TItem[],
  value: string,
  options: Options<TItem>
): TItem[] {
  const {
    keys,
    threshold = rankings.MATCHES,
    baseSort = defaultBaseSortFn,
    sorter = (matchedItems) =>
      matchedItems.sort(
        (a: RankingWithIndex<TItem>, b: RankingWithIndex<TItem>) =>
          sortRankedValues(a, b, baseSort)
      ),
  } = options;

  function reduceItemsToRanked(
    matches: RankingWithIndex<TItem>[],
    item: TItem,
    index: number
  ) {
    const rankingInfo = getHighestRanking(item, keys, value, options);
    const { rank, keyThreshold = threshold } = rankingInfo;
    if (rank >= keyThreshold) {
      matches.push({ ...rankingInfo, item, index });
    }
    return matches;
  }

  const matchedItems = items.reduce(reduceItemsToRanked, []);
  const sorted = sorter(matchedItems).map(({ item }) => item);
  return sorted;
}

matchSorter.rankings = rankings;

function getHighestRanking<TItem>(
  item: string,
  keys: undefined,
  value: string,
  options: Options<TItem>
): RankingWithIndex<TItem>;
function getHighestRanking<TItem>(
  item: TItem,
  keys: string[],
  value: string,
  options: Options<TItem>
): RankingWithIndex<TItem>;

function getHighestRanking<TItem>(
  item: string | TItem,
  keys: string[] | undefined,
  value: string,
  options: Options<TItem>
): Ranking {
  if (!keys) {
    const stringItem = item as string;
    return {
      rankedValue: stringItem,
      rank: getMatchRanking(stringItem, value, options),
      keyIndex: -1,
      keyThreshold: options.threshold,
    };
  }

  const valuesToRank = getAllValuesToRank(item, keys);

  return valuesToRank.reduce(
    (
      { rank, rankedValue, keyIndex, keyThreshold }: Ranking,
      { itemValue, attributes },
      i
    ) => {
      let newRank = getMatchRanking(itemValue, value, options);
      let newRankedValue = rankedValue;
      const { minRanking, maxRanking, threshold } = attributes;
      if (newRank < minRanking && newRank >= rankings.MATCHES) {
        newRank = minRanking;
      } else if (newRank > maxRanking) {
        newRank = maxRanking;
      }
      if (newRank > rank) {
        rank = newRank;
        keyIndex = i;
        keyThreshold = threshold;
        newRankedValue = itemValue;
      }
      return { rankedValue: newRankedValue, rank, keyIndex, keyThreshold };
    },
    {
      rankedValue: item,
      rank: rankings.NO_MATCH,
      keyIndex: -1,
      keyThreshold: options.threshold,
    }
  );
}

function getMatchRanking<TItem>(
  testString: string,
  stringToRank: string,
  options: Options<TItem>
) {
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);
  if (stringToRank.length > testString.length) {
    return rankings.NO_MATCH;
  }
  if (testString === stringToRank) {
    return rankings.CASE_SENSITIVE_EQUAL;
  }
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();
  if (testString === stringToRank) {
    return rankings.EQUAL;
  }
  if (testString.startsWith(stringToRank)) {
    return rankings.STARTS_WITH;
  }
  if (testString.includes(` ${stringToRank}`)) {
    return rankings.WORD_STARTS_WITH;
  }
  if (testString.includes(stringToRank)) {
    return rankings.CONTAINS;
  } else if (stringToRank.length === 1) {
    return rankings.NO_MATCH;
  }
  if (getAcronym(testString).includes(stringToRank)) {
    return rankings.ACRONYM;
  }
  return getClosenessRanking(testString, stringToRank);
}

function getAcronym(string: string): string {
  let acronym = "";
  const wordsInString = string.split(" ");
  for (const wordInString of wordsInString) {
    const splitByHyphenWords = wordInString.split("-");
    for (const splitByHyphenWord of splitByHyphenWords) {
      acronym += splitByHyphenWord.substr(0, 1);
    }
  }
  return acronym;
}

function getClosenessRanking(testString: string, stringToRank: string) {
  let matchingInOrderCharCount = 0;
  let charNumber = 0;

  function findMatchingCharacter(
    matchChar: string | undefined,
    string: string,
    index: number
  ): number | -1 {
    for (let j = index, J = string.length; j < J; j++) {
      const stringChar = string[j];
      if (stringChar === matchChar) {
        matchingInOrderCharCount += 1;
        return j + 1;
      }
    }
    return -1;
  }

  function getRanking(spread: number) {
    const spreadPercentage = 1 / spread;
    const inOrderPercentage = matchingInOrderCharCount / stringToRank.length;
    const RankingWithIndex =
      rankings.MATCHES + inOrderPercentage * spreadPercentage;
    return RankingWithIndex;
  }

  const firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);
  if (firstIndex < 0) {
    return rankings.NO_MATCH;
  }
  charNumber = firstIndex;
  for (let i = 1, I = stringToRank.length; i < I; i++) {
    const matchChar = stringToRank[i]!;
    charNumber = findMatchingCharacter(matchChar, testString, charNumber);
    const found = charNumber > -1;
    if (!found) {
      return rankings.NO_MATCH;
    }
  }
  const spread = charNumber - firstIndex;
  return getRanking(spread);
}

function sortRankedValues<TItem>(
  a: RankingWithIndex<TItem>,
  b: RankingWithIndex<TItem>,
  baseSort: NonNullable<Options<TItem>["baseSort"]>
) {
  const aFirst = -1;
  const bFirst = 1;
  const { rank: aRank, keyIndex: aKeyIndex } = a;
  const { rank: bRank, keyIndex: bKeyIndex } = b;
  const same = aRank === bRank;
  if (same) {
    if (aKeyIndex === bKeyIndex) {
      return baseSort(a, b);
    } else {
      return aKeyIndex < bKeyIndex ? aFirst : bFirst;
    }
  } else {
    return aRank > bRank ? aFirst : bFirst;
  }
}

function prepareValueForComparison<TItem>(
  value: string,
  { keepDiacritics }: Options<TItem>
) {
  value = `${value}`;
  if (!keepDiacritics) {
    value = removeAccents(value);
  }
  return value;
}

function getItemValues<
  TItem,
  TKey extends string,
  TValue,
  TReturn extends string
>(item: TItem, key: TKey): TReturn[] {
  if (typeof key === "object") {
    key = key.key;
  }

  let value: TValue | null;

  if (typeof key === "function") {
    value = key(item);
  } else if (item == null) {
    value = null;
  } else if (Object.hasOwn(item, key)) {
    value = item[key];
  } else if (key.includes(".")) {
    return getNestedValues(key, item);
  } else {
    value = null;
  }

  if (value == null) {
    return [];
  }

  if (Array.isArray(value)) {
    return value;
  }

  return [String(value)];
}

function getNestedValues<TItem>(path: string, item: TItem): TItem[] {
  const keys = path.split(".");
  let values = [item];
  for (let i = 0, I = keys.length; i < I; i++) {
    const nestedKey = keys[i]!;
    let nestedValues: TItem[] = [];
    for (let j = 0, J = values.length; j < J; j++) {
      const nestedItem = values[j];
      if (nestedItem == null) continue;
      if (Object.hasOwn(nestedItem, nestedKey)) {
        const nestedValue = nestedItem[nestedKey];
        if (nestedValue != null) {
          nestedValues.push(nestedValue);
        }
      } else if (nestedKey === "*") {
        nestedValues = nestedValues.concat(nestedItem);
      }
    }
    values = nestedValues;
  }
  if (Array.isArray(values[0])) {
    const result: TItem[] = [];
    return result.concat(...values);
  }
  return values;
}

function getAllValuesToRank<TItem>(
  item: TItem,
  keys: string[]
): {
  itemValue: string;
  attributes: any & {
    maxRanking: number;
    minRanking: number;
  };
}[] {
  const allValues = [];
  for (let j = 0, J = keys.length; j < J; j++) {
    const key = keys[j]!;
    const attributes = getKeyAttributes(key);
    const itemValues = getItemValues(item, key);
    for (let i = 0, I = itemValues.length; i < I; i++) {
      allValues.push({
        itemValue: itemValues[i]!,
        attributes,
      });
    }
  }
  return allValues;
}

const defaultKeyAttributes = {
  maxRanking: Infinity,
  minRanking: -Infinity,
};

function getKeyAttributes(key: string | any): any & {
  maxRanking: number;
  minRanking: number;
} {
  if (typeof key === "string") {
    return defaultKeyAttributes;
  }
  return { ...defaultKeyAttributes, ...key };
}
